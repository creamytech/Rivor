generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id            String         @id @default(cuid())
  email         String         @unique
  emailVerified DateTime?
  name          String?
  image         String?
  timezone      String         @default("America/New_York")
  createdAt     DateTime       @default(now())
  updatedAt     DateTime       @updatedAt
  accounts      Account[]
  emailAccounts EmailAccount[] @relation("UserEmailAccounts")
  oauthAccounts OAuthAccount[]
  orgMembers    OrgMember[]
  sessions      Session[]
  chatThreads   ChatThread[]
  notifications Notification[]
}

model Account {
  id                String   @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token_enc Bytes?   // Encrypted OAuth tokens (SOC2 compliant)
  access_token_enc  Bytes?   // Encrypted OAuth tokens (SOC2 compliant) 
  id_token_enc      Bytes?   // Encrypted OAuth tokens (SOC2 compliant)
  expires_at        Int?
  token_type        String?
  scope             String?
  session_state     String?
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
  user              User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime
  createdAt  DateTime @default(now())

  @@unique([identifier, token])
}

model Org {
  id                   String                @id @default(cuid())
  name                 String
  slug                 String?
  ownerUserId          String?
  brandName            String                @default("Rivor")
  encryptedDekBlob     Bytes
  dekVersion           Int                   @default(1)
  ephemeralMode        Boolean               @default(false)
  retentionDays        Int                   @default(90)
  createdAt            DateTime              @default(now())
  updatedAt            DateTime              @updatedAt
  audits               AuditLog[]
  calendarAccounts     CalendarAccount[]
  calendarEvents       CalendarEvent[]
  contacts             Contact[]
  emailAccounts        EmailAccount[]
  messages             EmailMessage[]
  threads              EmailThread[]
  leads                Lead[]
  members              OrgMember[]
  pipelineStages       PipelineStage[]
  pushNotificationLogs PushNotificationLog[]
  secureTokens         SecureToken[]         @relation("OrgSecureTokens")
  stripeCustomers      StripeCustomer[]
  subscriptions        Subscription[]
  tasks                Task[]
  notifications        Notification[]
  webhookSubscriptions WebhookSubscription[]
  chatThreads         ChatThread[]
  documents           Document[]
  documentTemplates   DocumentTemplate[]
  documentFolders     DocumentFolder[]
}

model OrgMember {
  id            String   @id @default(cuid())
  orgId         String
  userId        String
  role          String   @default("member")
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  assignedLeads Lead[]   @relation("LeadAssignments")
  org           Org      @relation(fields: [orgId], references: [id], onDelete: Cascade)
  user          User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  assignedTasks Task[]   @relation("TaskAssignments")

  @@unique([orgId, userId])
}

model OAuthAccount {
  id           String    @id @default(cuid())
  userId       String
  provider     String
  providerId   String
  accessToken  Bytes
  refreshToken Bytes
  scope        String?
  expiresAt    DateTime?
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt
  user         User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerId])
}

model EmailAccount {
  id                   String                @id @default(cuid())
  orgId                String
  userId               String
  provider             String
  externalAccountId    String
  email                String
  displayName          String?
  status               ConnectionStatus      @default(connected)
  syncStatus           SyncStatus            @default(idle)
  lastSyncedAt         DateTime?
  errorReason          String?
  encryptionStatus     EncryptionStatus      @default(pending)
  keyVersion           Int?
  kmsErrorCode         String?
  kmsErrorAt           DateTime?
  tokenRef             String?
  tokenStatus          String                @default("pending_encryption")
  historyId            String?
  watchExpiration      DateTime?
  watchResourceId      String?
  lastPushReceivedAt   DateTime?
  createdAt            DateTime              @default(now())
  updatedAt            DateTime              @updatedAt
  org                  Org                   @relation(fields: [orgId], references: [id], onDelete: Cascade)
  user                 User                  @relation("UserEmailAccounts", fields: [userId], references: [id], onDelete: Cascade)
  threads              EmailThread[]
  pushNotificationLogs PushNotificationLog[]

  @@unique([userId, provider])
  @@unique([orgId, provider, externalAccountId])
}

model SecureToken {
  id                 String           @id @default(cuid())
  tokenRef           String           @unique
  orgId              String
  provider           String
  tokenType          String
  encryptedTokenBlob Bytes?
  encryptionStatus   EncryptionStatus @default(pending)
  keyVersion         Int?
  kmsErrorCode       String?
  kmsErrorAt         DateTime?
  expiresAt          DateTime?
  retryCount         Int              @default(0)
  lastRetryAt        DateTime?
  createdAt          DateTime         @default(now())
  updatedAt          DateTime         @updatedAt
  org                Org              @relation("OrgSecureTokens", fields: [orgId], references: [id], onDelete: Cascade)

  @@index([tokenRef])
  @@index([orgId, provider])
  @@index([encryptionStatus])
}

model EmailThread {
  id                String         @id @default(cuid())
  orgId             String
  accountId         String
  subjectEnc        Bytes?
  participantsEnc   Bytes?
  summaryEnc        Bytes?
  summaryAt         DateTime?
  createdAt         DateTime       @default(now())
  updatedAt         DateTime       @updatedAt
  labels            String[]       @default([])
  starred           Boolean        @default(false)
  unread            Boolean        @default(true)
  messages          EmailMessage[]
  account           EmailAccount   @relation(fields: [accountId], references: [id], onDelete: Cascade)
  org               Org            @relation(fields: [orgId], references: [id], onDelete: Cascade)
}

model EmailMessage {
  id                 String      @id @default(cuid())
  threadId           String
  orgId              String
  messageId          String
  sentAt             DateTime
  fromEnc            Bytes?
  toEnc              Bytes?
  ccEnc              Bytes?
  bccEnc             Bytes?
  subjectEnc         Bytes?
  snippetEnc         Bytes?
  bodyRefEnc         Bytes?
  htmlBodyEnc        Bytes?
  textBodyEnc        Bytes?
  attachmentsMetaEnc Bytes?
  attachments        Json?
  createdAt          DateTime    @default(now())
  updatedAt          DateTime    @updatedAt
  org                Org         @relation(fields: [orgId], references: [id], onDelete: Cascade)
  thread             EmailThread @relation(fields: [threadId], references: [id], onDelete: Cascade)

  @@unique([orgId, messageId])
}

model CalendarAccount {
  id                String          @id @default(cuid())
  orgId             String
  provider          String
  status            String          @default("connected")
  channelId         String?
  channelResourceId String?
  channelExpiration DateTime?
  webhookEndpoint   String?
  createdAt         DateTime        @default(now())
  updatedAt         DateTime        @updatedAt
  org               Org             @relation(fields: [orgId], references: [id], onDelete: Cascade)
  events            CalendarEvent[]

  @@unique([orgId, provider])
}

model CalendarEvent {
  id            String          @id @default(cuid())
  orgId         String
  accountId     String
  start         DateTime
  end           DateTime
  titleEnc      Bytes?
  locationEnc   Bytes?
  notesEnc      Bytes?
  attendeesEnc  Bytes?
  createdAt     DateTime        @default(now())
  updatedAt     DateTime        @updatedAt
  account       CalendarAccount @relation(fields: [accountId], references: [id], onDelete: Cascade)
  org           Org             @relation(fields: [orgId], references: [id], onDelete: Cascade)
}

model Contact {
  id           String    @id @default(cuid())
  orgId        String
  nameEnc      Bytes?
  emailEnc     Bytes?
  phoneEnc     Bytes?
  companyEnc   Bytes?
  titleEnc     Bytes?
  addressEnc   Bytes?
  notesEnc     Bytes?
  source       String?
  tags         String[]
  lastActivity DateTime?
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt
  org          Org       @relation(fields: [orgId], references: [id], onDelete: Cascade)
  leads        Lead[]
  documents    Document[] @relation("DocumentContacts")
  folders      DocumentFolder[] @relation("FolderContacts")
}

model Lead {
  id                 String         @id @default(cuid())
  orgId              String
  contactId          String?
  stageId            String?
  title              String?
  dealValueEnc       Bytes?
  probabilityPercent Int?
  notesEnc           Bytes?
  status             String         @default("active")
  priority           String         @default("medium")
  source             String?
  assignedToId       String?
  sourceThreadId     String?
  propertyAddress    String?
  listingId          String?
  propertyValue      Float?
  automationEnabled  Boolean        @default(false)
  lastFollowUpAt     DateTime?
  expectedCloseDate  DateTime?
  actualCloseDate    DateTime?
  createdAt          DateTime       @default(now())
  updatedAt          DateTime       @updatedAt
  assignedTo         OrgMember?     @relation("LeadAssignments", fields: [assignedToId], references: [id])
  contact            Contact?       @relation(fields: [contactId], references: [id])
  org                Org            @relation(fields: [orgId], references: [id], onDelete: Cascade)
  stage              PipelineStage? @relation(fields: [stageId], references: [id])
  tasks              Task[]         @relation("LeadTasks")
  documents          Document[]     @relation("DocumentDeals")
  folders            DocumentFolder[] @relation("FolderDeals")
}

model Task {
  id             String     @id @default(cuid())
  orgId          String
  title          String
  description    String?
  status         String     @default("pending") // pending, in_progress, completed, cancelled
  dueAt          DateTime?
  completedAt    DateTime?
  done           Boolean    @default(false)
  priority       String     @default("medium")
  assignedToId   String?
  linkThreadId   String?
  linkLeadId     String?
  linkedEmailId  String?    // For linking to email threads
  linkedContactId String?   // For linking to contacts
  createdAt      DateTime   @default(now())
  updatedAt      DateTime   @updatedAt
  assignedTo     OrgMember? @relation("TaskAssignments", fields: [assignedToId], references: [id])
  lead           Lead?      @relation("LeadTasks", fields: [linkLeadId], references: [id])
  org            Org        @relation(fields: [orgId], references: [id], onDelete: Cascade)
}

model PipelineStage {
  id        String   @id @default(cuid())
  orgId     String
  name      String
  order     Int
  color     String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  leads     Lead[]
  org       Org      @relation(fields: [orgId], references: [id], onDelete: Cascade)

  @@unique([orgId, order])
}

model WebhookSubscription {
  id        String   @id @default(cuid())
  orgId     String
  provider  String
  secret    Bytes
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  org       Org      @relation(fields: [orgId], references: [id], onDelete: Cascade)
}

model StripeCustomer {
  id            String         @id @default(cuid())
  orgId         String
  customerId    String         @unique
  createdAt     DateTime       @default(now())
  updatedAt     DateTime       @updatedAt
  org           Org            @relation(fields: [orgId], references: [id], onDelete: Cascade)
  subscriptions Subscription[]
}

model Subscription {
  id               String         @id @default(cuid())
  orgId            String
  stripeCustomerId String
  status           String
  priceId          String
  seats            Int            @default(1)
  trialEndsAt      DateTime?
  currentPeriodEnd DateTime?
  createdAt        DateTime       @default(now())
  updatedAt        DateTime       @updatedAt
  org              Org            @relation(fields: [orgId], references: [id], onDelete: Cascade)
  stripe           StripeCustomer @relation(fields: [stripeCustomerId], references: [id], onDelete: Cascade)
}

model AuditLog {
  id        String   @id @default(cuid())
  orgId     String
  actorId   String?
  action    String
  purpose   String?
  resource  String?
  success   Boolean
  traceId   String?
  createdAt DateTime @default(now())
  org       Org      @relation(fields: [orgId], references: [id], onDelete: Cascade)
}

model PushNotificationLog {
  id             String       @id @default(cuid())
  emailAccountId String
  orgId          String
  provider       String
  historyId      String?
  processedAt    DateTime     @default(now())
  latencyMs      Int?
  success        Boolean      @default(true)
  errorMessage   String?
  emailAccount   EmailAccount @relation(fields: [emailAccountId], references: [id], onDelete: Cascade)
  org            Org          @relation(fields: [orgId], references: [id], onDelete: Cascade)

  @@index([emailAccountId, processedAt(sort: Desc)])
  @@index([orgId, processedAt(sort: Desc)])
}

model ChatThread {
  id          String        @id @default(cuid())
  orgId       String
  userId      String
  contextType String?
  contextId   String?
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt
  messages    ChatMessage[]
  org         Org           @relation(fields: [orgId], references: [id], onDelete: Cascade)
  user        User          @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([orgId])
  @@index([userId])
}

model ChatMessage {
  id        String      @id @default(cuid())
  threadId  String
  role      String
  content   String
  reasoning String?
  createdAt DateTime    @default(now())
  thread    ChatThread  @relation(fields: [threadId], references: [id], onDelete: Cascade)

  @@index([threadId])
  @@index([createdAt])
}

model Notification {
  id        String   @id @default(cuid())
  orgId     String
  userId    String
  type      String
  title     String
  message   String
  priority  String   @default("low")
  isRead    Boolean  @default(false)
  createdAt DateTime @default(now())
  readAt    DateTime?
  org       Org      @relation(fields: [orgId], references: [id], onDelete: Cascade)
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([orgId])
  @@index([userId])
}

model DocumentTemplate {
  id          String     @id @default(cuid())
  orgId       String
  name        String     // Encrypted
  description String?    // Encrypted
  category    String     @default("other") // listing, purchase, disclosure, agreement, marketing, legal, other
  content     String     // Encrypted template content
  mergeFields String     // JSON array of merge field keys
  isActive    Boolean    @default(true)
  createdAt   DateTime   @default(now())
  updatedAt   DateTime   @updatedAt
  org         Org        @relation(fields: [orgId], references: [id], onDelete: Cascade)
  documents   Document[]

  @@index([orgId])
  @@index([category])
  @@index([isActive])
}

model Document {
  id                   String            @id @default(cuid())
  orgId                String
  name                 String            // Encrypted
  templateId           String?
  content              String            // Encrypted document content
  status               String            @default("draft") // draft, generated, sent, signed, completed
  linkedDealId         String?
  linkedContactId      String?
  folderId             String?
  generatedPdfUrl      String?           // Encrypted URL to generated PDF
  docusignEnvelopeId   String?           // DocuSign envelope ID
  signedAt             DateTime?
  createdAt            DateTime          @default(now())
  updatedAt            DateTime          @updatedAt
  org                  Org               @relation(fields: [orgId], references: [id], onDelete: Cascade)
  template             DocumentTemplate? @relation(fields: [templateId], references: [id])
  folder               DocumentFolder?   @relation(fields: [folderId], references: [id])
  linkedDeal           Lead?             @relation("DocumentDeals", fields: [linkedDealId], references: [id])
  linkedContact        Contact?          @relation("DocumentContacts", fields: [linkedContactId], references: [id])

  @@index([orgId])
  @@index([status])
  @@index([linkedDealId])
  @@index([linkedContactId])
  @@index([folderId])
}

model DocumentFolder {
  id              String           @id @default(cuid())
  orgId           String
  name            String           // Encrypted
  parentId        String?
  linkedDealId    String?
  linkedContactId String?
  color           String?
  isArchived      Boolean          @default(false)
  createdAt       DateTime         @default(now())
  updatedAt       DateTime         @updatedAt
  org             Org              @relation(fields: [orgId], references: [id], onDelete: Cascade)
  parent          DocumentFolder?  @relation("FolderHierarchy", fields: [parentId], references: [id])
  children        DocumentFolder[] @relation("FolderHierarchy")
  documents       Document[]
  linkedDeal      Lead?            @relation("FolderDeals", fields: [linkedDealId], references: [id])
  linkedContact   Contact?         @relation("FolderContacts", fields: [linkedContactId], references: [id])

  @@index([orgId])
  @@index([parentId])
  @@index([linkedDealId])
  @@index([linkedContactId])
  @@index([isArchived])
}

model Waitlist {
  id        String   @id @default(cuid())
  email     String   @unique
  firstName String?
  role      String?  // 'agent', 'broker', 'team', 'other'
  note      String?
  consent   Boolean  @default(true)
  source    String   @default("marketing")
  ip        String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([createdAt])
  @@index([source])
  @@index([role])
}


enum ConnectionStatus {
  connected
  action_needed
  disconnected
}

enum SyncStatus {
  idle
  scheduled
  running
  error
}

enum EncryptionStatus {
  ok
  pending
  failed
}

