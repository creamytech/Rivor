generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                    String         @id @default(cuid())
  email                 String         @unique
  emailVerified         DateTime?
  name                  String?
  image                 String?
  timezone              String         @default("America/New_York")
  personalityOnboarded  Boolean        @default(false) // AI personality onboarding completion
  createdAt             DateTime       @default(now())
  updatedAt             DateTime       @updatedAt
  accounts              Account[]
  emailAccounts         EmailAccount[] @relation("UserEmailAccounts")
  oauthAccounts         OAuthAccount[]
  orgMembers            OrgMember[]
  sessions              Session[]
  chatThreads           ChatThread[]
  notifications         Notification[]
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? // Standard NextAuth fields
  access_token      String?
  id_token          String?
  expires_at        Int?
  token_type        String?
  scope             String?
  session_state     String?
  refresh_token_expires_in Int? // Added for Google OAuth compatibility
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
  user              User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime
  createdAt  DateTime @default(now())

  @@unique([identifier, token])
}

model Org {
  id                   String                @id @default(cuid())
  name                 String
  slug                 String?
  ownerUserId          String?
  brandName            String                @default("Rivor")
  encryptedDekBlob     Bytes
  dekVersion           Int                   @default(1)
  ephemeralMode        Boolean               @default(false)
  retentionDays        Int                   @default(90)
  createdAt            DateTime              @default(now())
  updatedAt            DateTime              @updatedAt
  audits               AuditLog[]
  calendarAccounts     CalendarAccount[]
  calendarEvents       CalendarEvent[]
  contacts             Contact[]
  emailAccounts        EmailAccount[]
  messages             EmailMessage[]
  threads              EmailThread[]
  leads                Lead[]
  leadIntelligence     LeadIntelligence[] @relation("OrgLeadIntelligence")
  members              OrgMember[]
  pipelineStages       PipelineStage[]
  pushNotificationLogs PushNotificationLog[]
  secureTokens         SecureToken[]         @relation("OrgSecureTokens")
  stripeCustomers      StripeCustomer[]
  subscriptions        Subscription[]
  tasks                Task[]
  notifications        Notification[]
  webhookSubscriptions WebhookSubscription[]
  chatThreads         ChatThread[]
  documents           Document[]
  documentTemplates   DocumentTemplate[]
  documentFolders     DocumentFolder[]
  leadInsights        LeadInsight[] @relation("OrgLeadInsights")
  leadPredictions     LeadPrediction[] @relation("OrgLeadPredictions") 
  communicationOptimizations CommunicationOptimization[] @relation("OrgCommunicationOptimization")
  automatedAppointments AutomatedAppointment[] @relation("OrgAppointments")
  followUpSequences FollowUpSequence[] @relation("OrgFollowUpSequences")
  followUpExecutions FollowUpExecution[] @relation("OrgFollowUpExecutions")
  aiGeneratedContent AIGeneratedContent[] @relation("OrgAIContent")
  automationRules AutomationRule[] @relation("OrgAutomationRules")
  showingTemplates PropertyShowingTemplate[] @relation("OrgShowingTemplates")
  agentPersonality AgentPersonality? @relation("OrgAgentPersonality")
  onboardingSessions OnboardingSession[] @relation("OrgOnboardingSessions")
  personalityTraining AIPersonalityTraining[] @relation("OrgPersonalityTraining")
  communicationTemplates CommunicationTemplate[] @relation("OrgCommunicationTemplates")
}

model OrgMember {
  id            String   @id @default(cuid())
  orgId         String
  userId        String
  role          String   @default("member")
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  assignedLeads Lead[]   @relation("LeadAssignments")
  org           Org      @relation(fields: [orgId], references: [id], onDelete: Cascade)
  user          User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  assignedTasks Task[]   @relation("TaskAssignments")

  @@unique([orgId, userId])
}

model OAuthAccount {
  id           String    @id @default(cuid())
  userId       String
  provider     String
  providerId   String
  accessToken  Bytes
  refreshToken Bytes
  scope        String?
  expiresAt    DateTime?
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt
  user         User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerId])
}

model EmailAccount {
  id                   String                @id @default(cuid())
  orgId                String
  userId               String
  provider             String
  externalAccountId    String
  email                String
  displayName          String?
  status               ConnectionStatus      @default(connected)
  syncStatus           SyncStatus            @default(idle)
  lastSyncedAt         DateTime?
  errorReason          String?
  encryptionStatus     EncryptionStatus      @default(pending)
  keyVersion           Int?
  kmsErrorCode         String?
  kmsErrorAt           DateTime?
  tokenRef             String?
  tokenStatus          String                @default("pending_encryption")
  historyId            String?
  watchExpiration      DateTime?
  watchResourceId      String?
  lastPushReceivedAt   DateTime?
  createdAt            DateTime              @default(now())
  updatedAt            DateTime              @updatedAt
  org                  Org                   @relation(fields: [orgId], references: [id], onDelete: Cascade)
  user                 User                  @relation("UserEmailAccounts", fields: [userId], references: [id], onDelete: Cascade)
  threads              EmailThread[]
  pushNotificationLogs PushNotificationLog[]

  @@unique([userId, provider])
  @@unique([orgId, provider, externalAccountId])
}

model SecureToken {
  id                 String           @id @default(cuid())
  tokenRef           String           @unique
  orgId              String
  provider           String
  tokenType          String
  encryptedTokenBlob Bytes?
  encryptionStatus   EncryptionStatus @default(pending)
  keyVersion         Int?
  kmsErrorCode       String?
  kmsErrorAt         DateTime?
  expiresAt          DateTime?
  retryCount         Int              @default(0)
  lastRetryAt        DateTime?
  createdAt          DateTime         @default(now())
  updatedAt          DateTime         @updatedAt
  org                Org              @relation("OrgSecureTokens", fields: [orgId], references: [id], onDelete: Cascade)

  @@index([tokenRef])
  @@index([orgId, provider])
  @@index([encryptionStatus])
}

model EmailThread {
  id                String            @id @default(cuid())
  orgId             String
  accountId         String
  subjectEnc        Bytes?
  participantsEnc   Bytes?
  summaryEnc        Bytes?
  summaryAt         DateTime?
  createdAt         DateTime          @default(now())
  updatedAt         DateTime          @updatedAt
  labels            String[]          @default([])
  starred           Boolean           @default(false)
  unread            Boolean           @default(true)
  messages          EmailMessage[]
  aiAnalysis        EmailAIAnalysis[]
  account           EmailAccount      @relation(fields: [accountId], references: [id], onDelete: Cascade)
  org               Org               @relation(fields: [orgId], references: [id], onDelete: Cascade)
}

model EmailMessage {
  id                 String      @id @default(cuid())
  threadId           String
  orgId              String
  messageId          String
  sentAt             DateTime
  fromEnc            Bytes?
  toEnc              Bytes?
  ccEnc              Bytes?
  bccEnc             Bytes?
  subjectEnc         Bytes?
  snippetEnc         Bytes?
  bodyRefEnc         Bytes?
  htmlBodyEnc        Bytes?
  textBodyEnc        Bytes?
  attachmentsMetaEnc Bytes?
  attachments        Json?
  createdAt          DateTime    @default(now())
  updatedAt          DateTime    @updatedAt
  org                Org         @relation(fields: [orgId], references: [id], onDelete: Cascade)
  thread             EmailThread @relation(fields: [threadId], references: [id], onDelete: Cascade)

  @@unique([orgId, messageId])
}

model CalendarAccount {
  id                String          @id @default(cuid())
  orgId             String
  provider          String
  status            String          @default("connected")
  channelId         String?
  channelResourceId String?
  channelExpiration DateTime?
  webhookEndpoint   String?
  createdAt         DateTime        @default(now())
  updatedAt         DateTime        @updatedAt
  org               Org             @relation(fields: [orgId], references: [id], onDelete: Cascade)
  events            CalendarEvent[]

  @@unique([orgId, provider])
}

model CalendarEvent {
  id            String          @id @default(cuid())
  orgId         String
  accountId     String
  start         DateTime
  end           DateTime
  titleEnc      Bytes?
  locationEnc   Bytes?
  notesEnc      Bytes?
  attendeesEnc  Bytes?
  createdAt     DateTime        @default(now())
  updatedAt     DateTime        @updatedAt
  account       CalendarAccount @relation(fields: [accountId], references: [id], onDelete: Cascade)
  org           Org             @relation(fields: [orgId], references: [id], onDelete: Cascade)
}

model Contact {
  id           String    @id @default(cuid())
  orgId        String
  nameEnc      Bytes?
  emailEnc     Bytes?
  phoneEnc     Bytes?
  companyEnc   Bytes?
  titleEnc     Bytes?
  addressEnc   Bytes?
  notesEnc     Bytes?
  source       String?
  tags         String[]
  lastActivity DateTime?
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt
  org          Org       @relation(fields: [orgId], references: [id], onDelete: Cascade)
  leads        Lead[]
  documents    Document[] @relation("DocumentContacts")
  folders      DocumentFolder[] @relation("FolderContacts")
  intelligence LeadIntelligence[] @relation("ContactIntelligence")
  appointments AutomatedAppointment[] @relation("ContactAppointments")
  followUps    FollowUpExecution[] @relation("ContactFollowUps")
}

model Lead {
  id                 String         @id @default(cuid())
  orgId              String
  contactId          String?
  stageId            String?
  title              String?
  dealValueEnc       Bytes?
  probabilityPercent Int?
  notesEnc           Bytes?
  status             String         @default("active")
  priority           String         @default("medium")
  source             String?
  assignedToId       String?
  sourceThreadId     String?
  propertyAddress    String?
  listingId          String?
  propertyValue      Float?
  automationEnabled  Boolean        @default(false)
  lastFollowUpAt     DateTime?
  expectedCloseDate  DateTime?
  actualCloseDate    DateTime?
  createdAt          DateTime       @default(now())
  updatedAt          DateTime       @updatedAt
  assignedTo         OrgMember?     @relation("LeadAssignments", fields: [assignedToId], references: [id])
  contact            Contact?       @relation(fields: [contactId], references: [id])
  org                Org            @relation(fields: [orgId], references: [id], onDelete: Cascade)
  stage              PipelineStage? @relation(fields: [stageId], references: [id])
  tasks              Task[]         @relation("LeadTasks")
  documents          Document[]     @relation("DocumentDeals")
  folders            DocumentFolder[] @relation("FolderDeals")
  intelligence       LeadIntelligence[] @relation("LeadIntelligence")
  appointments       AutomatedAppointment[] @relation("LeadAppointments")
  followUps          FollowUpExecution[] @relation("LeadFollowUps")
}

model Task {
  id             String     @id @default(cuid())
  orgId          String
  title          String
  description    String?
  status         String     @default("pending") // pending, in_progress, completed, cancelled
  dueAt          DateTime?
  completedAt    DateTime?
  done           Boolean    @default(false)
  priority       String     @default("medium")
  assignedToId   String?
  linkThreadId   String?
  linkLeadId     String?
  linkedEmailId  String?    // For linking to email threads
  linkedContactId String?   // For linking to contacts
  createdAt      DateTime   @default(now())
  updatedAt      DateTime   @updatedAt
  assignedTo     OrgMember? @relation("TaskAssignments", fields: [assignedToId], references: [id])
  lead           Lead?      @relation("LeadTasks", fields: [linkLeadId], references: [id])
  org            Org        @relation(fields: [orgId], references: [id], onDelete: Cascade)
}

model PipelineStage {
  id        String   @id @default(cuid())
  orgId     String
  name      String
  position  Int      // Changed from 'order' to 'position'
  color     String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  leads     Lead[]
  org       Org      @relation(fields: [orgId], references: [id], onDelete: Cascade)

  @@unique([orgId, position])
}

model WebhookSubscription {
  id        String   @id @default(cuid())
  orgId     String
  provider  String
  secret    Bytes
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  org       Org      @relation(fields: [orgId], references: [id], onDelete: Cascade)
}

model StripeCustomer {
  id            String         @id @default(cuid())
  orgId         String
  customerId    String         @unique
  createdAt     DateTime       @default(now())
  updatedAt     DateTime       @updatedAt
  org           Org            @relation(fields: [orgId], references: [id], onDelete: Cascade)
  subscriptions Subscription[]
}

model Subscription {
  id               String         @id @default(cuid())
  orgId            String
  stripeCustomerId String
  status           String
  priceId          String
  seats            Int            @default(1)
  trialEndsAt      DateTime?
  currentPeriodEnd DateTime?
  createdAt        DateTime       @default(now())
  updatedAt        DateTime       @updatedAt
  org              Org            @relation(fields: [orgId], references: [id], onDelete: Cascade)
  stripe           StripeCustomer @relation(fields: [stripeCustomerId], references: [id], onDelete: Cascade)
}

model AuditLog {
  id        String   @id @default(cuid())
  orgId     String
  actorId   String?
  action    String
  purpose   String?
  resource  String?
  success   Boolean
  traceId   String?
  createdAt DateTime @default(now())
  org       Org      @relation(fields: [orgId], references: [id], onDelete: Cascade)
}

model PushNotificationLog {
  id             String       @id @default(cuid())
  emailAccountId String
  orgId          String
  provider       String
  historyId      String?
  processedAt    DateTime     @default(now())
  latencyMs      Int?
  success        Boolean      @default(true)
  errorMessage   String?
  emailAccount   EmailAccount @relation(fields: [emailAccountId], references: [id], onDelete: Cascade)
  org            Org          @relation(fields: [orgId], references: [id], onDelete: Cascade)

  @@index([emailAccountId, processedAt(sort: Desc)])
  @@index([orgId, processedAt(sort: Desc)])
}

model ChatThread {
  id          String        @id @default(cuid())
  orgId       String
  userId      String
  contextType String?
  contextId   String?
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt
  messages    ChatMessage[]
  org         Org           @relation(fields: [orgId], references: [id], onDelete: Cascade)
  user        User          @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([orgId])
  @@index([userId])
}

model ChatMessage {
  id        String      @id @default(cuid())
  threadId  String
  role      String
  content   String
  reasoning String?
  createdAt DateTime    @default(now())
  thread    ChatThread  @relation(fields: [threadId], references: [id], onDelete: Cascade)

  @@index([threadId])
  @@index([createdAt])
}

model Notification {
  id        String   @id @default(cuid())
  orgId     String
  userId    String
  type      String
  title     String
  message   String
  priority  String   @default("low")
  isRead    Boolean  @default(false)
  createdAt DateTime @default(now())
  readAt    DateTime?
  org       Org      @relation(fields: [orgId], references: [id], onDelete: Cascade)
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([orgId])
  @@index([userId])
}

model DocumentTemplate {
  id          String     @id @default(cuid())
  orgId       String
  name        String     // Encrypted
  description String?    // Encrypted
  category    String     @default("other") // listing, purchase, disclosure, agreement, marketing, legal, other
  content     String     // Encrypted template content
  mergeFields String     // JSON array of merge field keys
  isActive    Boolean    @default(true)
  createdAt   DateTime   @default(now())
  updatedAt   DateTime   @updatedAt
  org         Org        @relation(fields: [orgId], references: [id], onDelete: Cascade)
  documents   Document[]

  @@index([orgId])
  @@index([category])
  @@index([isActive])
}

model Document {
  id                   String            @id @default(cuid())
  orgId                String
  name                 String            // Encrypted
  templateId           String?
  content              String            // Encrypted document content
  status               String            @default("draft") // draft, generated, sent, signed, completed
  linkedDealId         String?
  linkedContactId      String?
  folderId             String?
  generatedPdfUrl      String?           // Encrypted URL to generated PDF
  docusignEnvelopeId   String?           // DocuSign envelope ID
  signedAt             DateTime?
  createdAt            DateTime          @default(now())
  updatedAt            DateTime          @updatedAt
  org                  Org               @relation(fields: [orgId], references: [id], onDelete: Cascade)
  template             DocumentTemplate? @relation(fields: [templateId], references: [id])
  folder               DocumentFolder?   @relation(fields: [folderId], references: [id])
  linkedDeal           Lead?             @relation("DocumentDeals", fields: [linkedDealId], references: [id])
  linkedContact        Contact?          @relation("DocumentContacts", fields: [linkedContactId], references: [id])

  @@index([orgId])
  @@index([status])
  @@index([linkedDealId])
  @@index([linkedContactId])
  @@index([folderId])
}

model DocumentFolder {
  id              String           @id @default(cuid())
  orgId           String
  name            String           // Encrypted
  parentId        String?
  linkedDealId    String?
  linkedContactId String?
  color           String?
  isArchived      Boolean          @default(false)
  createdAt       DateTime         @default(now())
  updatedAt       DateTime         @updatedAt
  org             Org              @relation(fields: [orgId], references: [id], onDelete: Cascade)
  parent          DocumentFolder?  @relation("FolderHierarchy", fields: [parentId], references: [id])
  children        DocumentFolder[] @relation("FolderHierarchy")
  documents       Document[]
  linkedDeal      Lead?            @relation("FolderDeals", fields: [linkedDealId], references: [id])
  linkedContact   Contact?         @relation("FolderContacts", fields: [linkedContactId], references: [id])

  @@index([orgId])
  @@index([parentId])
  @@index([linkedDealId])
  @@index([linkedContactId])
  @@index([isArchived])
}

model Waitlist {
  id        String   @id @default(cuid())
  email     String   @unique
  firstName String?
  role      String?  // 'agent', 'broker', 'team', 'other'
  note      String?
  consent   Boolean  @default(true)
  source    String   @default("marketing")
  ip        String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([createdAt])
  @@index([source])
  @@index([role])
}


enum ConnectionStatus {
  connected
  action_needed
  disconnected
}

enum SyncStatus {
  idle
  scheduled
  running
  error
}

enum EncryptionStatus {
  ok
  pending
  failed
}

// AI Email Models
enum EmailCategory {
  hot_lead
  showing_request
  price_inquiry
  seller_lead
  buyer_lead
  follow_up
  contract
  marketing
}

enum ProcessingStatus {
  pending
  processing
  completed
  failed
}

enum ReplyStatus {
  pending
  approved
  rejected
  modified
  sent
  draft
}

enum FeedbackType {
  positive
  negative
  neutral
}

enum ProcessingType {
  analysis
  reply_generation
  categorization
}

enum QueueStatus {
  queued
  processing
  completed
  failed
  retry
}

model EmailAIAnalysis {
  id               String           @id @default(cuid())
  emailId          String           @unique @db.VarChar(255)
  threadId         String           @db.VarChar(255)
  category         EmailCategory
  priorityScore    Int              @default(0)
  leadScore        Int              @default(0)
  confidenceScore  Decimal          @default(0.00) @db.Decimal(3, 2)
  sentimentScore   Decimal          @default(0.50) @db.Decimal(3, 2)
  keyEntities      Json?
  processingStatus ProcessingStatus @default(pending)
  createdAt        DateTime         @default(now())
  updatedAt        DateTime         @updatedAt
  thread           EmailThread      @relation(fields: [threadId], references: [id], onDelete: Cascade)

  @@index([category])
  @@index([priorityScore])
  @@index([threadId])
}

model AISuggestedReply {
  id                String         @id @default(cuid())
  emailId           String         @db.VarChar(255)
  threadId          String         @db.VarChar(255)
  suggestedContent  String         @db.Text
  status            ReplyStatus    @default(pending)
  confidenceScore   Decimal        @default(0.00) @db.Decimal(3, 2)
  category          String         @db.VarChar(100)
  userModifications String?        @db.Text
  sentAt            DateTime?
  createdAt         DateTime       @default(now())
  updatedAt         DateTime       @updatedAt
  feedback          AIFeedback[]

  @@index([emailId])
  @@index([status])
  @@index([threadId])
}

model AIFeedback {
  id                     String      @id @default(cuid())
  replyId                String
  feedbackType           FeedbackType
  userComments           String?     @db.Text
  responseEffectiveness  Int?        // 1-5 scale
  createdAt              DateTime    @default(now())
  reply                  AISuggestedReply @relation(fields: [replyId], references: [id], onDelete: Cascade)

  @@index([replyId])
  @@index([feedbackType])
}

model AIEmailTemplate {
  id              String   @id @default(cuid())
  name            String   @db.VarChar(255)
  category        String   @db.VarChar(100)
  templateContent String   @db.Text
  variables       Json?    // Placeholder variables like {propertyAddress}, {clientName}
  isActive        Boolean  @default(true)
  usageCount      Int      @default(0)
  successRate     Decimal  @default(0.00) @db.Decimal(3, 2)
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@index([category])
  @@index([isActive])
}

model AIProcessingQueue {
  id             String         @id @default(cuid())
  emailId        String         @db.VarChar(255)
  threadId       String         @db.VarChar(255)
  processingType ProcessingType
  status         QueueStatus    @default(queued)
  priority       Int            @default(50) // 1-100, higher is more urgent
  attempts       Int            @default(0)
  maxAttempts    Int            @default(3)
  errorMessage   String?        @db.Text
  scheduledFor   DateTime?
  startedAt      DateTime?
  completedAt    DateTime?
  createdAt      DateTime       @default(now())
  updatedAt      DateTime       @updatedAt

  @@index([status])
  @@index([priority])
  @@index([scheduledFor])
  @@index([emailId])
}

// Smart Lead Intelligence Models
model LeadIntelligence {
  id                    String   @id @default(cuid())
  orgId                 String
  leadId                String?  // Optional - can analyze non-lead contacts too
  contactId             String?
  emailThreadId         String?
  overallScore          Int      @default(0) // 0-100 composite lead score
  conversionProbability Float    @default(0.0) // 0.0-1.0 probability of conversion
  engagementScore       Int      @default(0) // 0-100 how engaged they are
  urgencyScore          Int      @default(0) // 0-100 how urgent/time-sensitive
  valueScore            Int      @default(0) // 0-100 estimated deal value potential
  responsePatterns      Json?    // Analysis of their communication patterns
  behaviorMetrics       Json?    // Website visits, email opens, response times
  predictedActions      Json?    // Next likely actions they'll take
  recommendedActions    Json?    // Suggested actions for the agent
  optimalContactTime    String?  // Best time to contact (morning/afternoon/evening)
  communicationStyle    String?  // formal/casual/direct/relationship-focused
  decisionTimeframe     String?  // immediate/short_term/long_term
  painPoints           Json?     // Identified pain points/motivations
  competitorMentions   Json?     // Mentions of competitors
  priceSignals         Json?     // Price sensitivity indicators
  lastAnalyzedAt       DateTime?
  createdAt            DateTime @default(now())
  updatedAt            DateTime @updatedAt
  org                  Org      @relation("OrgLeadIntelligence", fields: [orgId], references: [id], onDelete: Cascade)
  lead                 Lead?    @relation("LeadIntelligence", fields: [leadId], references: [id], onDelete: Cascade)
  contact              Contact? @relation("ContactIntelligence", fields: [contactId], references: [id], onDelete: Cascade)
  insights             LeadInsight[] @relation("IntelligenceInsights")
  predictions          LeadPrediction[] @relation("IntelligencePredictions")
  optimization         CommunicationOptimization? @relation("IntelligenceOptimization")

  @@unique([orgId, leadId])
  @@unique([orgId, contactId])
  @@index([overallScore])
  @@index([conversionProbability])
  @@index([urgencyScore])
  @@index([lastAnalyzedAt])
}

model LeadInsight {
  id                String   @id @default(cuid())
  orgId             String
  leadIntelligenceId String
  type              String   // behavior_change, engagement_spike, urgency_increase, competitor_mention, etc.
  category          String   // positive, negative, neutral, urgent
  title             String
  description       String
  confidence        Float    @default(0.0) // 0.0-1.0 confidence in this insight
  impact            String   // high, medium, low
  actionRequired    Boolean  @default(false)
  suggestedActions  Json?    // Array of suggested responses
  dataPoints        Json?    // Supporting data for this insight
  isRead            Boolean  @default(false)
  dismissedAt       DateTime?
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
  org               Org      @relation("OrgLeadInsights", fields: [orgId], references: [id], onDelete: Cascade)
  leadIntelligence  LeadIntelligence @relation("IntelligenceInsights", fields: [leadIntelligenceId], references: [id], onDelete: Cascade)

  @@index([orgId])
  @@index([category])
  @@index([impact])
  @@index([actionRequired])
  @@index([isRead])
  @@index([createdAt])
}

model LeadPrediction {
  id                 String   @id @default(cuid())
  orgId              String
  leadIntelligenceId String
  predictionType     String   // conversion, timeline, value, next_action
  prediction         String   // The actual prediction text
  probability        Float    @default(0.0) // Confidence in prediction
  timeframe          String?  // When this prediction applies
  factors            Json?    // Contributing factors
  modelVersion       String   @default("1.0")
  accuracy           Float?   // Actual vs predicted (updated over time)
  validatedAt        DateTime?
  expiresAt          DateTime?
  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt
  org                Org      @relation("OrgLeadPredictions", fields: [orgId], references: [id], onDelete: Cascade)
  leadIntelligence   LeadIntelligence @relation("IntelligencePredictions", fields: [leadIntelligenceId], references: [id], onDelete: Cascade)

  @@index([orgId])
  @@index([predictionType])
  @@index([probability])
  @@index([expiresAt])
}

model CommunicationOptimization {
  id                 String   @id @default(cuid())
  orgId              String
  leadIntelligenceId String
  channelPreference  Json?    // email, phone, text - with preference scores
  bestContactTimes   Json?    // day_of_week and time preferences
  responsePatterns   Json?    // typical response times and patterns
  contentPreferences Json?    // formal/casual, brief/detailed, etc.
  engagementTriggers Json?    // What typically gets responses
  avoidancePatterns  Json?    // What to avoid
  lastOptimizedAt    DateTime?
  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt
  org                Org      @relation("OrgCommunicationOptimization", fields: [orgId], references: [id], onDelete: Cascade)
  leadIntelligence   LeadIntelligence @relation("IntelligenceOptimization", fields: [leadIntelligenceId], references: [id], onDelete: Cascade)

  @@unique([leadIntelligenceId])
  @@index([orgId])
}

// AI Assistant Replacement System Models

model AutomatedAppointment {
  id                String   @id @default(cuid())
  orgId             String
  contactId         String?
  leadId            String?
  emailThreadId     String?
  appointmentType   String   // showing, consultation, meeting, call
  status            String   @default("pending") // pending, confirmed, rescheduled, completed, cancelled
  scheduledAt       DateTime
  duration          Int      @default(60) // minutes
  location          String?
  propertyAddress   String?
  lockboxCode       String?
  showingInstructions String?
  attendeeEmails    Json?    // Array of email addresses
  remindersSent     Json?    // Track what reminders were sent
  confirmationToken String?  @unique
  rescheduleToken   String?  @unique
  aiNotes           String?  // AI-generated notes about the appointment
  requirements      Json?    // Special requirements or requests
  followUpSequence  String?  // Which follow-up sequence to trigger
  createdBy         String?  // User who created (or "system" for AI)
  completedAt       DateTime?
  cancelledAt       DateTime?
  cancelReason      String?
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
  org               Org      @relation("OrgAppointments", fields: [orgId], references: [id], onDelete: Cascade)
  contact           Contact? @relation("ContactAppointments", fields: [contactId], references: [id], onDelete: SetNull)
  lead              Lead?    @relation("LeadAppointments", fields: [leadId], references: [id], onDelete: SetNull)

  @@index([orgId])
  @@index([status])
  @@index([scheduledAt])
  @@index([appointmentType])
}

model FollowUpSequence {
  id             String   @id @default(cuid())
  orgId          String
  name           String
  description    String?
  sequenceType   String   // new_lead, showing_followup, contract_followup, etc.
  triggerEvent   String   // email_received, appointment_completed, lead_created, etc.
  isActive       Boolean  @default(true)
  steps          Json     // Array of sequence steps with timing and content
  conditions     Json?    // Conditions for when this sequence should trigger
  stats          Json?    // Performance statistics
  createdBy      String
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt
  org            Org      @relation("OrgFollowUpSequences", fields: [orgId], references: [id], onDelete: Cascade)
  executions     FollowUpExecution[]

  @@index([orgId])
  @@index([sequenceType])
  @@index([isActive])
}

model FollowUpExecution {
  id               String   @id @default(cuid())
  orgId            String
  sequenceId       String
  contactId        String?
  leadId           String?
  emailThreadId    String?
  currentStep      Int      @default(0)
  status           String   @default("active") // active, paused, completed, cancelled
  nextActionAt     DateTime?
  completedSteps   Json?    // Array of completed step details
  pausedAt         DateTime?
  pausedReason     String?
  completedAt      DateTime?
  performance      Json?    // Open rates, click rates, responses, etc.
  customizations   Json?    // Any custom variables or overrides
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt
  org              Org      @relation("OrgFollowUpExecutions", fields: [orgId], references: [id], onDelete: Cascade)
  sequence         FollowUpSequence @relation(fields: [sequenceId], references: [id], onDelete: Cascade)
  contact          Contact? @relation("ContactFollowUps", fields: [contactId], references: [id], onDelete: SetNull)
  lead             Lead?    @relation("LeadFollowUps", fields: [leadId], references: [id], onDelete: SetNull)

  @@index([orgId])
  @@index([status])
  @@index([nextActionAt])
  @@index([sequenceId])
}

model AIGeneratedContent {
  id             String   @id @default(cuid())
  orgId          String
  contentType    String   // email, sms, social_post, listing_description, etc.
  contentPurpose String   // follow_up, appointment_reminder, listing_update, etc.
  template       String?  // Template name or ID used
  prompt         String?  // AI prompt that generated this content
  generatedText  String   // The AI-generated content
  customizations Json?    // Any user customizations made
  performance    Json?    // Metrics like open rates, click rates, etc.
  isActive       Boolean  @default(true)
  usageCount     Int      @default(0)
  lastUsedAt     DateTime?
  createdBy      String
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt
  org            Org      @relation("OrgAIContent", fields: [orgId], references: [id], onDelete: Cascade)

  @@index([orgId])
  @@index([contentType])
  @@index([contentPurpose])
  @@index([isActive])
}

model AutomationRule {
  id          String   @id @default(cuid())
  orgId       String
  name        String
  description String?
  ruleType    String   // trigger_based, schedule_based, condition_based
  triggers    Json     // What events trigger this rule
  conditions  Json?    // Conditions that must be met
  actions     Json     // What actions to take
  isActive    Boolean  @default(true)
  priority    Int      @default(50) // 1-100, higher priority runs first
  stats       Json?    // Execution statistics
  lastRunAt   DateTime?
  nextRunAt   DateTime?
  createdBy   String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  org         Org      @relation("OrgAutomationRules", fields: [orgId], references: [id], onDelete: Cascade)

  @@index([orgId])
  @@index([isActive])
  @@index([ruleType])
  @@index([priority])
  @@index([nextRunAt])
}

model PropertyShowingTemplate {
  id                  String   @id @default(cuid())
  orgId               String
  name                String
  propertyType        String?  // residential, commercial, land, etc.
  defaultDuration     Int      @default(30) // minutes
  bufferTime          Int      @default(15) // minutes between showings
  instructions        String?  // Default showing instructions
  requiresApproval    Boolean  @default(false)
  availableTimeSlots  Json?    // Available time slots configuration
  confirmationMessage String?  // Custom confirmation message template
  reminderSchedule    Json?    // When to send reminders
  isActive            Boolean  @default(true)
  createdBy           String
  createdAt           DateTime @default(now())
  updatedAt           DateTime @updatedAt
  org                 Org      @relation("OrgShowingTemplates", fields: [orgId], references: [id], onDelete: Cascade)

  @@index([orgId])
  @@index([propertyType])
  @@index([isActive])
}

// AI Personality & Communication Style Learning System
model AgentPersonality {
  id                    String   @id @default(cuid())
  orgId                 String   @unique
  userId                String   // The agent's user ID
  onboardingCompleted   Boolean  @default(false)
  communicationStyle    String?  // formal, casual, friendly, professional, enthusiastic, etc.
  tonePreferences       Json?    // warmth, professionalism, urgency levels
  vocabularyPreferences Json?    // preferred words, phrases, industry terms
  signatureStyle        String?  // email signature style and content
  writingPatterns       Json?    // sentence length, paragraph structure, emoji usage
  responseStyle         Json?    // how they typically respond to different scenarios
  personalBrand         Json?    // unique value propositions, specialties, personality traits
  sampleCommunications  Json?    // analyzed samples of their actual communications
  learningProgress      Json?    // progress through onboarding steps
  refinementHistory     Json?    // history of manual corrections and improvements
  lastUpdated           DateTime @default(now())
  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt
  org                   Org      @relation("OrgAgentPersonality", fields: [orgId], references: [id], onDelete: Cascade)

  @@index([userId])
}

model OnboardingSession {
  id                    String   @id @default(cuid())
  orgId                 String
  userId                String
  sessionType           String   // personality_discovery, writing_sample, scenario_practice, refinement
  status                String   @default("in_progress") // in_progress, completed, paused
  currentStep           Int      @default(1)
  totalSteps            Int      @default(10)
  conversationHistory   Json?    // full conversation log with AI
  extractedInsights     Json?    // AI-analyzed insights from the conversation
  styleScores          Json?    // scored dimensions of communication style
  scenarioResponses     Json?    // responses to different real estate scenarios
  completedAt           DateTime?
  timeSpentMinutes      Int?     // total time spent in session
  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt
  org                   Org      @relation("OrgOnboardingSessions", fields: [orgId], references: [id], onDelete: Cascade)

  @@index([orgId])
  @@index([userId])
  @@index([status])
}

model AIPersonalityTraining {
  id                   String   @id @default(cuid())
  orgId                String
  personalityId        String   // References AgentPersonality
  trainingType         String   // email_samples, conversation_samples, scenario_responses
  originalContent      String   // original agent-written content
  aiGeneratedContent   String?  // AI's attempt to mimic the style  
  humanFeedback        String?  // agent's feedback on AI generation
  accuracyScore        Float?   // 0.0-1.0 how well AI matched agent style
  improvementNotes     Json?    // specific areas for improvement
  approved             Boolean  @default(false)
  usedForTraining      Boolean  @default(false)
  createdAt            DateTime @default(now())
  updatedAt            DateTime @updatedAt
  org                  Org      @relation("OrgPersonalityTraining", fields: [orgId], references: [id], onDelete: Cascade)

  @@index([orgId])
  @@index([personalityId])
  @@index([trainingType])
  @@index([approved])
}

model CommunicationTemplate {
  id                   String   @id @default(cuid())
  orgId                String
  personalityId        String   // References AgentPersonality
  templateType         String   // welcome_email, followup_email, appointment_confirmation, etc.
  scenario             String   // new_lead, hot_lead, cold_lead, appointment_reminder, etc.
  subjectLine          String?  // for email templates
  content              String   // the template content with personality applied
  variables            Json?    // available template variables like {first_name}, {property_address}
  usageCount           Int      @default(0)
  successRate          Float?   // response rate or conversion rate
  lastUsed             DateTime?
  isActive             Boolean  @default(true)
  version              Int      @default(1)
  parentTemplateId     String?  // for versioning
  generatedByAI        Boolean  @default(true)
  humanApproved        Boolean  @default(false)
  createdAt            DateTime @default(now())
  updatedAt            DateTime @updatedAt
  org                  Org      @relation("OrgCommunicationTemplates", fields: [orgId], references: [id], onDelete: Cascade)

  @@index([orgId])
  @@index([personalityId])
  @@index([templateType])
  @@index([scenario])
  @@index([isActive])
}

